/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { mockServerPool } from "../mock-server/MockServerPool";
import { MarkupAIClient } from "../../src/Client";
import * as MarkupAI from "../../src/api/index";

describe("StyleChecks", () => {
    test("getStyleCheck (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new MarkupAIClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = {
            config: {
                dialect: "canadian_english",
                style_guide: { style_guide_type: "ap", style_guide_id: "sg-8d4e5f6a-2b3c-4d5e-6f7a-8b9c0d1e2f3a" },
                tone: "conversational",
            },
            original: {
                issues: [
                    {
                        original: "therefor",
                        position: { start_index: 89 },
                        subcategory: "Grammar Agreement",
                        category: "grammar",
                    },
                    {
                        original: "leverage",
                        position: { start_index: 156 },
                        subcategory: "Grammar Agreement",
                        category: "clarity",
                    },
                    {
                        original: "going forward",
                        position: { start_index: 234 },
                        subcategory: "Grammar Agreement",
                        category: "tone",
                    },
                    {
                        original: "email",
                        position: { start_index: 312 },
                        subcategory: "Grammar Agreement",
                        category: "consistency",
                    },
                    {
                        original: "towards",
                        position: { start_index: 405 },
                        subcategory: "Grammar Agreement",
                        category: "consistency",
                    },
                ],
                scores: {
                    quality: {
                        score: 72,
                        grammar: { score: 95, issues: 1 },
                        consistency: { score: 80, issues: 2 },
                        terminology: { score: 100, issues: 0 },
                    },
                    analysis: {
                        clarity: {
                            score: 64,
                            flesch_reading_ease: 51.4,
                            sentence_complexity: 38.9,
                            vocabulary_complexity: 45.6,
                            sentence_count: 6,
                            word_count: 112,
                            average_sentence_length: 18.7,
                        },
                        tone: {
                            score: 78,
                            informality: 38.2,
                            liveliness: 33.9,
                            informality_alignment: 115.8,
                            liveliness_alignment: 106.4,
                        },
                    },
                },
            },
            workflow: {
                id: "chk-2b5f8d3a-9c7e-4f2b-a8d1-6e9c3f7b4a2d",
                api_version: "1.0.0",
                generated_at: "2025-01-15T14:22:33Z",
                status: "completed",
                type: "checks",
                webhook_response: { url: "https://api.example.com/webhook", status_code: 200 },
            },
        };
        server
            .mockEndpoint()
            .get("/v1/style/checks/workflow_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.styleChecks.getStyleCheck("workflow_id");
        expect(response).toEqual({
            config: {
                dialect: "canadian_english",
                style_guide: {
                    style_guide_type: "ap",
                    style_guide_id: "sg-8d4e5f6a-2b3c-4d5e-6f7a-8b9c0d1e2f3a",
                },
                tone: "conversational",
            },
            original: {
                issues: [
                    {
                        original: "therefor",
                        position: {
                            start_index: 89,
                        },
                        subcategory: "Grammar Agreement",
                        category: "grammar",
                    },
                    {
                        original: "leverage",
                        position: {
                            start_index: 156,
                        },
                        subcategory: "Grammar Agreement",
                        category: "clarity",
                    },
                    {
                        original: "going forward",
                        position: {
                            start_index: 234,
                        },
                        subcategory: "Grammar Agreement",
                        category: "tone",
                    },
                    {
                        original: "email",
                        position: {
                            start_index: 312,
                        },
                        subcategory: "Grammar Agreement",
                        category: "consistency",
                    },
                    {
                        original: "towards",
                        position: {
                            start_index: 405,
                        },
                        subcategory: "Grammar Agreement",
                        category: "consistency",
                    },
                ],
                scores: {
                    quality: {
                        score: 72,
                        grammar: {
                            score: 95,
                            issues: 1,
                        },
                        consistency: {
                            score: 80,
                            issues: 2,
                        },
                        terminology: {
                            score: 100,
                            issues: 0,
                        },
                    },
                    analysis: {
                        clarity: {
                            score: 64,
                            flesch_reading_ease: 51.4,
                            sentence_complexity: 38.9,
                            vocabulary_complexity: 45.6,
                            sentence_count: 6,
                            word_count: 112,
                            average_sentence_length: 18.7,
                        },
                        tone: {
                            score: 78,
                            informality: 38.2,
                            liveliness: 33.9,
                            informality_alignment: 115.8,
                            liveliness_alignment: 106.4,
                        },
                    },
                },
            },
            workflow: {
                id: "chk-2b5f8d3a-9c7e-4f2b-a8d1-6e9c3f7b4a2d",
                api_version: "1.0.0",
                generated_at: "2025-01-15T14:22:33Z",
                status: "completed",
                type: "checks",
                webhook_response: {
                    url: "https://api.example.com/webhook",
                    status_code: 200,
                },
            },
        });
    });

    test("getStyleCheck (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new MarkupAIClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = {
            config: {
                dialect: "american_english",
                style_guide: { style_guide_type: "ap", style_guide_id: "style_guide_id" },
                tone: "academic",
            },
            original: {
                issues: [{ original: "faze", position: { start_index: 356 }, subcategory: "Grammar Agreement" }],
            },
            workflow: {
                id: "checks-4a7c8e92-6f3d-4b8a-9c1e-2d5f7a9b3e4c",
                api_version: "1.0.0",
                generated_at: "2024-01-15T09:30:00Z",
                status: "running",
                type: "checks",
                webhook_response: { url: "url", status_code: 1 },
            },
        };
        server
            .mockEndpoint()
            .get("/v1/style/checks/workflow_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.styleChecks.getStyleCheck("workflow_id");
        expect(response).toEqual({
            config: {
                dialect: "american_english",
                style_guide: {
                    style_guide_type: "ap",
                    style_guide_id: "style_guide_id",
                },
                tone: "academic",
            },
            original: {
                issues: [
                    {
                        original: "faze",
                        position: {
                            start_index: 356,
                        },
                        subcategory: "Grammar Agreement",
                    },
                ],
            },
            workflow: {
                id: "checks-4a7c8e92-6f3d-4b8a-9c1e-2d5f7a9b3e4c",
                api_version: "1.0.0",
                generated_at: "2024-01-15T09:30:00Z",
                status: "running",
                type: "checks",
                webhook_response: {
                    url: "url",
                    status_code: 1,
                },
            },
        });
    });

    test("getStyleCheck (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new MarkupAIClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = {
            config: {
                dialect: "american_english",
                style_guide: { style_guide_type: "ap", style_guide_id: "style_guide_id" },
                tone: "academic",
            },
            original: {
                issues: [{ original: "faze", position: { start_index: 356 }, subcategory: "Grammar Agreement" }],
            },
            workflow: {
                id: "checks-4a7c8e92-6f3d-4b8a-9c1e-2d5f7a9b3e4c",
                api_version: "1.0.0",
                generated_at: "2024-01-15T09:30:00Z",
                status: "failed",
                type: "checks",
                webhook_response: { url: "url", status_code: 1 },
            },
        };
        server
            .mockEndpoint()
            .get("/v1/style/checks/workflow_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.styleChecks.getStyleCheck("workflow_id");
        expect(response).toEqual({
            config: {
                dialect: "american_english",
                style_guide: {
                    style_guide_type: "ap",
                    style_guide_id: "style_guide_id",
                },
                tone: "academic",
            },
            original: {
                issues: [
                    {
                        original: "faze",
                        position: {
                            start_index: 356,
                        },
                        subcategory: "Grammar Agreement",
                    },
                ],
            },
            workflow: {
                id: "checks-4a7c8e92-6f3d-4b8a-9c1e-2d5f7a9b3e4c",
                api_version: "1.0.0",
                generated_at: "2024-01-15T09:30:00Z",
                status: "failed",
                type: "checks",
                webhook_response: {
                    url: "url",
                    status_code: 1,
                },
            },
        });
    });

    test("getStyleCheck (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new MarkupAIClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: "detail", status: 1, request_id: "request_id" };
        server
            .mockEndpoint()
            .get("/v1/style/checks/workflow_id")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.styleChecks.getStyleCheck("workflow_id");
        }).rejects.toThrow(MarkupAI.UnauthorizedError);
    });

    test("getStyleCheck (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new MarkupAIClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: "detail", status: 1, request_id: "request_id" };
        server
            .mockEndpoint()
            .get("/v1/style/checks/workflow_id")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.styleChecks.getStyleCheck("workflow_id");
        }).rejects.toThrow(MarkupAI.ForbiddenError);
    });

    test("getStyleCheck (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new MarkupAIClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: "detail", status: 1, request_id: "request_id" };
        server
            .mockEndpoint()
            .get("/v1/style/checks/workflow_id")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.styleChecks.getStyleCheck("workflow_id");
        }).rejects.toThrow(MarkupAI.NotFoundError);
    });

    test("getStyleCheck (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new MarkupAIClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/v1/style/checks/workflow_id")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.styleChecks.getStyleCheck("workflow_id");
        }).rejects.toThrow(MarkupAI.UnprocessableEntityError);
    });

    test("getStyleCheck (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new MarkupAIClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: "detail", status: 1, request_id: "request_id" };
        server
            .mockEndpoint()
            .get("/v1/style/checks/workflow_id")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.styleChecks.getStyleCheck("workflow_id");
        }).rejects.toThrow(MarkupAI.InternalServerError);
    });
});
